# Autoscaling TensorFlow model deployments with TF Serving and Kubernetes

In this assignment, you will use TensorFlow Serving and Google Cloud Kubernetes Engine (GKE) to configure a high-performance, autoscalable serving system for TensorFlow models. More concretely, you will:

1. Create a GKE cluster and deploy a model.

2. Download the model files to a storage bucket.

3. Create Kubernetes ConfigMap that points to the location of the model in the storage bucket.

4. Create Kubernetes Deployment using a standard TensorFlow Serving image from Docker Hub.

5. Create Kubernetes Service to expose the deployment through a load balancer.

6. Configure Horizontal Pod Autoscaler.

7. Test the model.

# Overview

Serving deep learning models can be especially challenging. The models are often large, requiring gigabytes of memory. They are also very compute intensive - a small number of concurrent requests can fully utilize a CPU or GPU. Automatic horizontal scaling is one of the primary strategies used in architecting scalable and reliable model serving infrastructures for deep learning models.

In this lab, you will use TensorFlow Serving and Google Cloud Kubernetes Engine (GKE) to configure a high-performance, autoscalable serving system for TensorFlow models.

# Lab scenario

You will use TensorFlow Serving to deploy the ResNet101 model. TensorFlow Serving is a flexible, high-performance serving system for machine learning models, designed for production environments. TensorFlow Serving makes it easy to deploy new algorithms and experiments, while keeping the same server architecture and APIs. TensorFlow Serving provides out-of-the-box integration with TensorFlow models, but can be easily extended to serve other types of models and data.

TensorFlow Serving can be run in a docker container and deployed and managed by Kubernetes. In the lab, you will deploy TensorFlow Serving as a Kubernetes Deployment on Google Cloud Kubernetes Engine (GKE) and use Kubernetes Horizontal Pod Autoscaler to automatically scale the number of TensorFlow Serving replicas based on observed CPU utilization. You will also use GKE Cluster Autoscaler to automatically resize your GKE cluster's node pool based on the resource demands generated by the TensorFlow Serving Deployment.

Horizontal Pod Autoscaler automatically scales the number of Pods in a replication controller, deployment, replica set or stateful set based on observed CPU utilization (or, with custom metrics support, on some other application-provided metrics). Horizontal Pod Autoscaler is implemented as a Kubernetes API resource and a controller. The resource determines the behavior of the controller. The controller periodically adjusts the number of replicas in a replication controller or deployment to match the observed average CPU utilization to the target specified by the user.

GKE's Cluster Autoscaler automatically resizes the number of nodes in a given node pool, based on the demands of your workloads. You don't need to manually add or remove nodes or over-provision your node pools. Instead, you specify a minimum and maximum size for the node pool, and the rest is automatic.

After configuring the cluster and deploying TensorFlow Serving you will use an open source load testing tool Locust to generate prediction requests against the ResNet101 model and observe how the model deployment automatically scales up and down based on the load.

Summary of the tasks performed during the lab:

* Create a GKE cluster with autoscaling enabled on a default node pool
* Deploy the pretrained ResNet101 model using TensorFlow Serving
* Configure Horizontal Pod Autoscaler
* Install Locust
* Load the ResNet101 model
* Monitor the model deployment

# Lab tasks

You will use Cloud Shell and Cloud Console for all of the tasks in the lab. Some tasks require you to edit text files. You can use any of the classic command line text editors pre-installed in Cloud Shell, including vim, emacs, or nano. You can also use the built-in Cloud Shell Editor.

Before proceeding, make sure that you completed the Activate Cloud Shell step in the Setup and requirements instructions and your Cloud Shell is open and ready.

# Task 1. Getting lab files

Start by getting the lab files from GitHub:

```bash
cd
SRC_REPO=https://github.com/GoogleCloudPlatform/mlops-on-gcp
kpt pkg get $SRC_REPO/workshops/mlep-qwiklabs/tfserving-gke-autoscaling tfserving-gke
cd tfserving-gke
```

# Task 2. Creating a GKE cluster

1. Set the default compute zone and a couple of environment variables to store your project id and cluster name:

    ```bash
    gcloud config set compute/zone us-central1-f
    PROJECT_ID=$(gcloud config get-value project)
    CLUSTER_NAME=cluster-1
    ```

2. To create a cluster execute the below command - it may take a few minutes to complete:

    ```bash
    gcloud beta container clusters create $CLUSTER_NAME \
    --cluster-version=latest \
    --machine-type=n1-standard-4 \
    --enable-autoscaling \
    --min-nodes=1 \
    --max-nodes=3 \
    --num-nodes=1 
    ```

    After the command completes you should see the output similar to one below:

    ```bash
    To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-central1-f/cluster-1?project=qwiklabs-gcp-00-aea5e829799a
    kubeconfig entry generated for cluster-1.
    NAME: cluster-1
    LOCATION: us-central1-f
    MASTER_VERSION: 1.24.1-gke.1400
    MASTER_IP: 34.67.10.235
    MACHINE_TYPE: n1-standard-4
    NODE_VERSION: 1.24.1-gke.1400
    NUM_NODES: 1
    STATUS: RUNNING
    ```

3. The command created a CPU-based GKE cluster. The cluster has a default node pool, which is configured to autoscale from 1 to 3 nodes. Initially, the node pool has only one node.

    Get the credentials for you new cluster so you can interact with it using kubectl:

    ```bash
    gcloud container clusters get-credentials $CLUSTER_NAME 
    ```

# Task 3. Deploying ResNet101

The pretrained ResNet101 model in the SavedModel format has been uploaded to a public Cloud Storage location.

You will first download the model files to a storage bucket in your project. Since storage buckets are a global resource in Google Cloud you have to use a unique bucket name. For the purpose of this lab, you can use your project id as a name prefix.

1. To create a storage bucket in your project:

    ```bash
    export MODEL_BUCKET=${PROJECT_ID}-bucket
    gsutil mb gs://${MODEL_BUCKET}
    ```

2. After the bucket has been created, copy the model files:

    ```bash
    gsutil cp -r gs://spls/gsp777/resnet_101 gs://${MODEL_BUCKET}
    ```

You are now ready to deploy TensorFlow Serving to GKE and configure it to serve the ResNet101 model. You will deploy TF Serving in four steps:

1. First you will create a [Kubernetes ConfigMap](https://kubernetes.io/docs/concepts/configuration/configmap/) that points to the location of the ResNet101 model in your storage bucket.

2. Then, you will create a [Kubernetes Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) using a [standard TensorFlow Serving image](https://hub.docker.com/r/tensorflow/serving) from Docker Hub.

3. When the deployment is ready, you will create a [Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/) to expose the deployment through a load balancer.

4. Finally, you will configure Horizontal Pod Autoscaler.

# Task 4. Creating ConfigMap

1. Use your preferred command line editor or Cloud Shell Editor to update the MODEL_PATH field in the tf-serving/configmap.yaml file to reference your bucket. Recall that the bucket name was stored in the $MODEL_BUCKET environment variable:

    ```bash
    echo $MODEL_BUCKET
    ```

    After the update the configmap.yaml should look similar to the one below:

    ```bash
    apiVersion: v1
    kind: ConfigMap
    metadata:
    name: tfserving-configs
    data:
    MODEL_NAME: image_classifier
    MODEL_PATH: gs://qwiklabs-gcp-03-4b91a600a7a2-bucket/resnet_101
    ```

2. Using kubectl create the ConfigMap:

    ```bash
    kubectl apply -f tf-serving/configmap.yaml
    ```

# Task 5. Creating TensorFlow Serving deployment

1. Inspect the manifest for the TensorFlow Serving deployment:

    ```bash
    cat tf-serving/deployment.yaml
    ```

    Notice that the TF Serving process is configured to serve the model referenced by the MODEL_PATH environment variable and that this variable is set by the ConfigMap you created in the previous step.

    ```bash
    ...
        spec:
        containers:
        - name: tf-serving
            image: "tensorflow/serving"
            args: 
            - "--model_name=$(MODEL_NAME)"
            - "--model_base_path=$(MODEL_PATH)" 
            envFrom:
            - configMapRef:
                name: tfserving-configs
    ...
    ```

    Also notice that the deployment is configured to start with one replica.

    ```bash
    ...
    apiVersion: apps/v1
    kind: Deployment
    metadata:
    name: image-classifier
    namespace: default
    labels:
        app: image-classifier
    spec:
    replicas: 1
    ...
    ```

    In the deployment manifest, there is an explicit request for CPU and RAM resources:

    ```bash
    ...
    resources:
    requests:
        cpu: "3"
        memory: 4Gi
    ...
    ```

    At start, each replica requests 3 CPUs and 4 Gigabytes of RAM. Your cluster is configured with n1-standard-4 nodes that have 4 virtual CPUs and 15GB or RAM. It means that only a single replica can run on a node.

2. Create the deployment:

    ```bash
    kubectl apply -f tf-serving/deployment.yaml
    ```

    It may take a few minutes before the deployment is ready.

3. To check the status of the deployment:

    ```bash
    kubectl get deployments
    ```

4. Wait till the READY column in the output of the previous command changes to 1/1.

# Task 6. Exposing the deployment

1. Inspect the manifest for the service:

    ```bash
    cat tf-serving/service.yaml
    ```

    Notice that the service is of type LoadBalancer and that it exposes two ports: 8500 and 8501. By default, Tensorflow Serving uses port 8500 for the gRPC interface and port 8501 for the REST interface.

    ```bash
    ...
    spec:
    type: LoadBalancer
    ports:
    - port: 8500
        protocol: TCP
        name: tf-serving-grpc
    - port: 8501
        protocol: TCP
        name: tf-serving-http
    selector:
        app: image-classifier
    ...
    ```

2. Create the service:

    ```bash
    kubectl apply -f tf-serving/service.yaml
    ```

    It may take a few minutes before the service is operational. Wait till the external IP address exposed by the service has been set.

3. You can check the status of provisioning the service by executing the following command:

    ```bash
    kubectl get svc image-classifier
    ```

    When the service is ready, you should see output that provides service details.

# Task 7. Configuring horizontal pod autoscaler

The final step is to add Horizontal Pod Autoscaler (HPA). The command below configures HPA to start a new replica of TensorFlow Serving whenever the mean CPU utilization across all already running replicas reaches 60%. HPA will attempt to create up to 4 replicas and scale down to 1 replica.

1. Enter the command:

    ```bash
    kubectl autoscale deployment image-classifier \
    --cpu-percent=60 \
    --min=1 \
    --max=4 
    ```

2. Check the status of the HPA:

    ```bash
    kubectl get hpa
    ```

# Task 8. Testing the model

The Tensorflow Serving model server is now up and running. You can test it by submitting a request using the curl command. In the locust folder you can find a sample request body (request-body.json) formatted to conform to the [TensorFlow Serving REST API](https://www.tensorflow.org/tfx/serving/api_rest). It contains a picture of [Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper).

![Grace Hopper](./grace_hopper.png "Grace Hopper")

To invoke the model set the `EXTERNAL_IP` environment variable to the external IP of your service and execute the `curl` command:

```bash
EXTERNAL_IP=[YOUR_SERVICE_IP]
curl -d @locust/request-body.json -X POST http://${EXTERNAL_IP}:8501/v1/models/image_classifier:predict
```

The response returned by the model includes the list of the 5 most likely labels with the associated probabilities.

# Task 9. Installing Locust

You are now ready to load test the ResNet101 model. As described previously, you will use an open source load testing tool Locust to generate prediction requests.

1. To install Locust:

    ```bash
    pip3 install locust==1.4.1
    ```

    The installation process can take a few minutes. The Locust command line interface (CLI) gets installed into the `~/.local/bin` folder which is not on PATH.

2. You need to add this folder to PATH:

    ```bash
    export PATH=~/.local/bin:$PATH
    ```

3. To validate the installation and show the Locust version number:

    ```bash
    locust -V
    ```

# Task 10. Starting a load test

The locust folder contains the Locust script that generates prediction requests against the ResNet101 model. The script uses the same request body you used previously to verify the TensorFlow Serving deployment. The script is configured to progressively increase the number of simulated users that send prediction requests to the ResNet101 model. After reaching the maximum number of configured users, the script stops generating the load. The number of users is adjusted every 60s.

Refer to Locust documentation for more information on Locust settings.

* To start the test, execute the command:

    ```bash
    cd locust
    locust -f tasks.py \
    --headless \
    --host http://${EXTERNAL_IP}:8501
    ```

# Task 11. Monitoring the load test

You will monitor the behavior of the TensorFlow Serving deployment and the GKE node pool using [GKE Dashboards](https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards).

1. To monitor the TensorFlow Serving deployment open a new tab in the same browser window in which you run Cloud Shell and navigate to the following URL:

    ```bash
    <https://console.cloud.google.com/kubernetes/deployment/us-central1-f/cluster-1/default/image-classifier/overview>
    ```

    The Image-Classifier page opens.

    Two lines on the CPU line chart in the upper left part of the page show the requested and the currently utilized CPUs. As the load increases, the number of requested CPUs will increase in steps of 3 as new replicas are started. The number of used CPUs will be a ragged curve representing the current utilization averaged across all allocated CPU resources. The CPU line chart shows data delayed by about 60 seconds.

    Note that you need to click on the Refresh button on the top menu to see the updates.

    The Managed pods widget shows the current number of replicas. At the beginning of the test it will show one replica:

    ![Managed Pod 1](./managed_pod_1.png "Managed Pod 1")

    Soon you will see two pods. One running and one in the unschedulable state:

    ![Managed Pod 2](./managed_pod_2.png "Managed Pod 2")

    Recall that only one TensorFlow Serving pod can fit on a single cluster node. The pod stays in the unschedulable state while GKE autoscaler creates a new node.

2. After both pods are in the running state you can verify that a new node has been created in the default node pool by opening the node pool dashboard in another browser tab.

    ```bash
    https://console.cloud.google.com/kubernetes/nodepool/us-central1-f/cluster-1/default-pool
    ```

    ![Nodes](./nodes.png "Nodes")

    At some point the fourth replica is scheduled:

    ![Managed Pod 3](./managed_pod_3.png "Managed Pod 3")

    The fourth replica will not transition to the running state as the GKE autoscaler was configured to create a maximum of three nodes.

    After about 15 minutes, the script stops sending requests. As a result, the number of TensorFlow Serving replicas will also go down.

    By default, the HPA will wait for 5 minutes before triggering the downscaling operation so you will need to wait at least 5 minutes to observe this behavior.

    As the number of replicas goes down, the GKE autoscaler starts removing nodes from the default node pool.

    For the purposes of scaling down, the autoscaler calculates the group's recommended target size based on peak load over the last 10 minutes. These last 10 minutes are referred to as the stabilization period. So be patient. It will take over 15 minutes after the script stopped generating predictions to see the changes in the size of the default node pool.

# Task 12. Stopping the load test

To stop the load test, kill the Locust process by issuing the Ctrl+C command in the Cloud Shell terminal.

# Congratulations

You used TensorFlow Serving and Google Kubernetes Engine to deploy and monitor the ResNet101 model!
