# Ungraded Lab - Introduction to Docker (Google Cloud)

In this lab, you will:

build, run, and debug Docker containers.

pull Docker images from Docker Hub and Google Artifact Registry.

push Docker images to Google Artifact Registry.

This course uses a third-party app, Ungraded Lab - Introduction to Docker (Google Cloud), to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.

# Task 1. Hello world

1. In Cloud Shell enter the following command to run a hello world container to get started:

    ```bash
    docker run hello-world
    ```

    This simple container returns Hello from Docker! to your screen. While the command is simple, notice in the output the number of steps it performed. The Docker daemon searched for the hello-world image, didn't find the image locally, pulled the image from a public registry called Docker Hub, created a container from that image, and ran the container for you.

2. Run the following command to take a look at the container image it pulled from Docker Hub:

    ```bash
    docker images
    ```

    This is the image pulled from the Docker Hub public registry. The Image ID is in SHA256 hash format—this field specifies the Docker image that's been provisioned. When the Docker daemon can't find an image locally, it will by default search the public registry for the image.

3. Run the container again:

    ```bash
    docker run hello-world
    ```

    Notice the second time you run this, the Docker daemon finds the image in your local registry and runs the container from that image. It doesn't have to pull the image from Docker Hub.

4. Finally, look at the running containers by running the following command:

    ```bash
    docker ps
    ```

    There are no running containers. You already exited the hello-world containers you previously ran.

5. In order to see all containers, including ones that have finished executing, run docker ps -a:

    ```bash
    docker ps -a
    ```

    This shows you the Container ID, a UUID generated by Docker to identify the container, and more metadata about the run. The container Names are also randomly generated but can be specified with docker run --name [container-name] hello-world.

# Task 2. Build

In this section, you will build a Docker image that's based on a simple node application.

1. Execute the following command to create and switch into a folder named test.

    ```bash
    mkdir test && cd test
    ```

2. Create a Dockerfile:

    ```bash
    cat > Dockerfile <<EOF
    # Use an official Node runtime as the parent image
    FROM node:lts
    # Set the working directory in the container to /app
    WORKDIR /app
    # Copy the current directory contents into the container at /app
    ADD . /app
    # Make the container's port 80 available to the outside world
    EXPOSE 80
    # Run app.js using node when the container launches
    CMD ["node", "app.js"]
    EOF
    ```

    This file instructs the Docker daemon on how to build your image.

    * The initial line specifies the base parent image, which in this case is the official Docker image for node version long term support (lts).
    * In the second, you set the working (current) directory of the container.
    * In the third, you add the current directory's contents (indicated by the "." ) into the container.
    * Then expose the container's port so it can accept connections on that port and finally run the node command to start the application.

    **Note**: Spend some time reviewing the Dockerfile command references to understand each line of the Dockerfile.

Now you'll write the node application, and after that you'll build the image.

3. Run the following to create the node application:

    ```bash
    cat > app.js <<EOF
    const http = require('http');
    const hostname = '0.0.0.0';
    const port = 80;
    const server = http.createServer((req, res) => {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Hello World\n');
    });
    server.listen(port, hostname, () => {
        console.log('Server running at http://%s:%s/', hostname, port);
    });
    process.on('SIGINT', function() {
        console.log('Caught interrupt signal and will exit');
        process.exit();
    });
    EOF
    ```

    This is a simple HTTP server that listens on port 80 and returns "Hello World".

    Now build the image.

4. Note again the ".", which means current directory so you need to run this command from within the directory that has the Dockerfile:

    ```bash
    docker build -t node-app:0.1 .
    ```

    It might take a couple of minutes for this command to finish executing. When it does, your output should resemble the following:

    ```bash
    Sending build context to Docker daemon 3.072 kB
    Step 1 : FROM node:lts
    6: Pulling from library/node
    ...
    ...
    ...
    Step 5 : CMD node app.js
    ---> Running in b677acd1edd9
    ---> f166cd2a9f10
    Removing intermediate container b677acd1edd9
    Successfully built f166cd2a9f10
    ```

    The `-t` is to name and tag an image with the name:tag syntax. The name of the image is node-app and the tag is 0.1. The tag is highly recommended when building Docker images. If you don't specify a tag, the tag will default to latest and it becomes more difficult to distinguish newer images from older ones. Also notice how each line in the Dockerfile above results in intermediate container layers as the image is built.

5. Now, run the following command to look at the images you built:

    Your output should resemble the following:

    ```bash
    REPOSITORY     TAG      IMAGE ID        CREATED            SIZE
    node-app       0.1      f166cd2a9f10    25 seconds ago     656.2 MB
    node           lts      5a767079e3df    15 hours ago       656.2 MB
    hello-world    latest   1815c82652c0    6 days ago         1.84 kB
    ```

    Notice node is the base image and node-app is the image you built. You can't remove node without removing node-app first. The size of the image is relatively small compared to VMs. Other versions of the node image such as node:slim and node:alpine can give you even smaller images for easier portability. The topic of slimming down container sizes is further explored in Advanced Topics. You can view all versions in the official repository in node.

# Task 3. Run

1. Use this code to run containers based on the image you built:

    ```bash
    docker run -p 4000:80 --name my-app node-app:0.1
    ```

    (Command Output)

    ```bash
    Server running at http://0.0.0.0:80/
    ```

    The `--name` flag allows you to name the container if you like. The `-p` instructs Docker to map the host's port 4000 to the container's port 80. Now you can reach the server at `http://localhost:4000`. Without port mapping, you would not be able to reach the container at localhost.

2. Open another terminal (in Cloud Shell, click the + icon), and test the server:

    ```bash
    curl http://localhost:4000
    ```

    (Command Output)

    ```bash
    Hello World
    ```

    The container will run as long as the initial terminal is running. If you want the container to run in the background (not tied to the terminal's session), you need to specify the -d flag.

3. Close the initial terminal and then run the following command to stop and remove the container:

    ```bash
    docker stop my-app && docker rm my-app
    ```

4. Now run the following command to start the container in the background:

    ```bash
    docker run -p 4000:80 --name my-app -d node-app:0.1
    docker ps
    ```

    (Command Output)

    ```bash
    CONTAINER ID   IMAGE          COMMAND        CREATED         ...  NAMES
    xxxxxxxxxxxx   node-app:0.1   "node app.js"  16 seconds ago  ...  my-app
    ```

5. Notice the container is running in the output of docker ps. You can look at the logs by executing docker logs [container_id].

    **Note**: You don't have to write the entire container ID, as long as the initial characters uniquely identify the container. For example, you can execute docker logs 17b if the container ID is 17bcaca6f....

    (Command Output)

    ```bash
    Server running at http://0.0.0.0:80/
    ```

    Now modify the application.

    In your Cloud Shell, open the test directory you created earlier in the lab:

    ```bash
    cd test
    ```

6. Edit app.js with a text editor of your choice (for example nano or vim) and replace "Hello World" with another string:

    ```bash
    ....
    const server = http.createServer((req, res) => {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.end('Welcome to Cloud\n');
    });
    ....
    ```

7. Build this new image and tag it with 0.2:

    ```bash
    docker build -t node-app:0.2 .
    ```

    (Command Output)

    ```bash
    Step 1/5 : FROM node:lts
    ---> 67ed1f028e71
    Step 2/5 : WORKDIR /app
    ---> Using cache
    ---> a39c2d73c807
    Step 3/5 : ADD . /app
    ---> a7087887091f
    Removing intermediate container 99bc0526ebb0
    Step 4/5 : EXPOSE 80
    ---> Running in 7882a1e84596
    ---> 80f5220880d9
    Removing intermediate container 7882a1e84596
    Step 5/5 : CMD node app.js
    ---> Running in f2646b475210
    ---> 5c3edbac6421
    Removing intermediate container f2646b475210
    Successfully built 5c3edbac6421
    Successfully tagged node-app:0.2
    ```

    Notice in Step 2 that you are using an existing cache layer. From Step 3 and on, the layers are modified because you made a change in app.js.

8. Run another container with the new image version. Notice how we map the host's port 8080 instead of 80. You can't use host port 4000 because it's already in use.

    ```bash
    docker run -p 8080:80 --name my-app-2 -d node-app:0.2
    docker ps
    ```

    (Command Output)

    ```bash
    CONTAINER ID     IMAGE             COMMAND            CREATED             
    xxxxxxxxxxxx     node-app:0.2      "node app.js"      53 seconds ago      ...
    xxxxxxxxxxxx     node-app:0.1      "node app.js"      About an hour ago   ...
    ```

9. Test the containers:

    ```bash
    curl http://localhost:8080
    ```

    (Command Output)

    ```bash
    Welcome to Cloud
    ```

10. And now test the first container you made:

    ```bash
    curl http://localhost:4000
    ```

    (Command Output)

    ```bash
    Hello World
    ```

# Task 4. Debug

Now that you're familiar with building and running containers, go over some debugging practices.

1. You can look at the logs of a container using docker logs [container_id]. If you want to follow the log's output as the container is running, use the -f option.

    ```bash
    docker logs -f [container_id]
    ```

    (Command Output)

    ```bash
    Server running at http://0.0.0.0:80/
    ```

    Sometimes you will want to start an interactive Bash session inside the running container.

2. You can use `docker exec` to do this. Open another terminal (in Cloud Shell, click the + icon) and enter the following command:

    ```bash
    docker exec -it [container_id] bash
    ```

    The -it flags let you interact with a container by allocating a pseudo-tty and keeping stdin open. Notice bash ran in the WORKDIR directory (/app) specified in the Dockerfile. From here, you have an interactive shell session inside the container to debug.

    (Command Output)

    ```bash
    root@xxxxxxxxxxxx:/app#
    ```

3. Look at the directory

    ```bash
    ls
    ```

    (Command Output)

    ```bash
    Dockerfile  app.js
    ```

4. Exit the Bash session:

    ```bash
    exit
    ```

5. You can examine a container's metadata in Docker by using Docker inspect:

    ```bash
    docker inspect [container_id]
    ```

    (Command Output)

    ```bash
    [
        {
            "Id": "xxxxxxxxxxxx....",
            "Created": "2017-08-07T22:57:49.261726726Z",
            "Path": "node",
            "Args": [
                "app.js"
            ],
    ...
    ```

6. Use --format to inspect specific fields from the returned JSON. For example:

    ```bash
    docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' [container_id]
    ```

    (Example Output)

    ```bash
    192.168.9.3
    ```

Be sure to check out the following Docker documentation resources for more information on debugging:

* [Docker inspect reference](https://docs.docker.com/engine/reference/commandline/inspect/#examples)
* [Docker exec reference](https://docs.docker.com/engine/reference/commandline/exec/)

# Task 5. Publish

Now you're going to push your image to the [Google Artifact Registry](https://cloud.google.com/artifact-registry). After that you'll remove all containers and images to simulate a fresh environment, and then pull and run your containers. This will demonstrate the portability of Docker containers.

To push images to your private registry hosted by Artifact Registry, you need to tag the images with a registry name. The format is `<regional-repository>-docker.pkg.dev/my-project/my-repo/my-image`.

## Create the target Docker repository

You must create a repository before you can push any images to it. Pushing an image can't trigger creation of a repository and the Cloud Build service account does not have permissions to create repositories.

1. From the Navigation Menu, under CI/CD navigate to Artifact Registry > Repositories.

2. Click Create Repository.

3. Specify my-repository as the repository name.

4. Choose Docker as the format.

5. Under Location Type, select Region and then choose the location us-central1 (Iowa).

6. Click Create.

##  Configure authentication

Before you can push or pull images, configure Docker to use the Google Cloud CLI to authenticate requests to Artifact Registry.

1. To set up authentication to Docker repositories in the region us-central1, run the following command in Cloud Shell:

    ```bash
    gcloud auth configure-docker us-central1-docker.pkg.dev
    ```

2. Enter `Y` when prompted.
    The command updates your Docker configuration. You can now connect with Artifact Registry in your Google Cloud project to push and pull images.

## Push the container to Artifact Registry

Run the following commands to set your Project ID and change into the directory with your Dockerfile.

    ```bash
    export PROJECT_ID=$(gcloud config get-value project)
    cd ~/test
    ```

3. Run the command to tag node-app:0.2.

    ```bash
    docker build -t us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/node-app:0.2 .
    ```

3. Run the following command to check your built Docker images.

    ```bash
    docker images
    ```

    (Command Output)

    ```bash
    REPOSITORY                      TAG         IMAGE ID          CREATED
    node-app                        0.2         76b3beef845e      22 hours
    us-central1-....node-app:0.2    0.2         76b3beef845e      22 hours
    node-app                        0.1         f166cd2a9f10      26 hours
    node                            lts         5a767079e3df      7 days
    hello-world                     latest      1815c82652c0      7 weeks
    ```

3. Push this image to Artifact Registry.

    ```bash
    docker push us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/node-app:0.2
    ```

    Command output (yours may differ):

    ```bash
    The push refers to a repository [us-central1-docker.pkg.dev/[project-id]/my-repository/node-app:0.2]
    057029400a4a: Pushed
    342f14cb7e2b: Pushed
    903087566d45: Pushed
    99dac0782a63: Pushed
    e6695624484e: Pushed
    da59b99bbd3b: Pushed
    5616a6292c16: Pushed
    f3ed6cb59ab0: Pushed
    654f45ecb7e3: Pushed
    2c40c66f7667: Pushed
    0.2: digest: sha256:25b8ebd7820515609517ec38dbca9086e1abef3750c0d2aff7f341407c743c46 size: 2419
    ```

4. After the build finishes, from the Navigation Menu, under CI/CD navigate to Artifact Registry > Repositories.

5. Click on my-repository. You should see your node-app Docker container created.

# Test the image

You could start a new VM, ssh into that VM, and install gcloud. For simplicity, just remove all containers and images to simulate a fresh environment.

1. Stop and remove all containers:

    ```bash
    docker stop $(docker ps -q)
    docker rm $(docker ps -aq)
    ```

You have to remove the child images (of node:lts) before you remove the node image.

2. Run the following command to remove all of the Docker images.

    ```bash
    docker rmi us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/node-app:0.2
    docker rmi node:lts
    docker rmi -f $(docker images -aq) # remove remaining images
    docker images
    ```

    (Command Output)

    ```bash
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    ```

At this point you should have a pseudo-fresh environment.

3. Pull the image and run it.

    ```bash
    docker pull us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/node-app:0.2
    docker run -p 4000:80 -d us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/node-app:0.2
    curl http://localhost:4000
    ```

    (Command Output)

    ```bash
    Welcome to Cloud
    ```
